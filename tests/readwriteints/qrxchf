#!/usr/bin/env python

# This submission script uses commandline options to allow user control over SGE job submission options. Run with -h flag to get comprehensive details of each flag and defaults
# The path to the rxchf bin directory is hardwired at the top of this script
# Quick start: qrxchf -N [jobname] will run a serial RXCHF job

import os
import sys
from subprocess import *
from optparse import OptionParser

# RXCHF executable details
rxchfpath="/home/asirjoos/codes/RXCHF/NEO-RXCHF/bin"   # Path to RXCHF executables

# Set up parser options
codeusage=sys.argv[0] + " -N [JOBNAME] ([options]) \n       where [JOBNAME] is the requested jobname"
parser=OptionParser(usage=codeusage)
parser.add_option("-e","--execut",action="store",dest="executable",type="string",default="runRXCHF",help="executable corresponding to [executable].exe (defaults to runRXCHF.exe)")
parser.add_option("-N","--jobname",action="store",dest="jobname",type="string",default="rxchf_job",help="jobname for SGE job (defaults to 'rxchf_job')")
parser.add_option("-w","--walltime",action="store",dest="walltime",type="int",default=500,help="walltime in integer hours (defaults to 500 hours)")
parser.add_option("-n","--nproc",action="store",dest="nproc",type="int",default=1,help="number of processors (defaults to 1)")
parser.add_option("-q","--queue",action="store",dest="queue",type="string",default="single4.q",help="queue (defaults to single4)")
parser.add_option("-m","--memory",action="store",dest="memory",type="int",default=60,help="memory required in GB (defaults to 60GB)")
(parseopts,parseargs)=parser.parse_args()
helpmsg=": use " + sys.argv[0] + " -h for help"

# Error-check user-defined options
acceptablequeues=["single.q","single1.q","single2.q","single3.q","single4.q"]
if parseopts.queue not in acceptablequeues:
 parser.error("Queue " + parseopts.queue + " is invalid" + helpmsg)
if parseopts.queue != "single4.q" and parseopts.memory > 60:
 parse.error("Memory request " + parseopts.memory + " is invalid with queue " + parseopts.queue + helpmsg)

walltimestr=str(parseopts.walltime)+":00:00"
memory=str(parseopts.memory)+"G"

# Build SGE script
currdir=os.getcwd()
user=os.environ["USER"]

qsubcmd="""
#!/bin/bash

qsub << eof
#$ -S /bin/bash
#$ -cwd
#$ -N $JOBNAME
#$ -pe default $NPROC
#$ -q $QUEUE
#$ -l h_rt=$WALLTIME
#$ -l virtual_free=$MEMORY
#$ -m n
#$ -o std.out
#$ -j y

echo \$JOB_ID

export SCR=/scratch/$USER/\$JOB_ID

mkdir \$SCR
if [ ! -e \$SCR ] ; then
 echo "Unable to make scratch directory"
 exit 0
fi

echo \$SCR

cat \$PE_HOSTFILE
echo $EXEC

if [ -e guessCE.inp ] ; then
  cp guessCE.inp \$SCR
fi

if [ -e guessCAE.inp ] ; then
  cp guessCAE.inp \$SCR
fi

if [ -e guessCAalpE.inp ] ; then
  cp guessCAalpE.inp \$SCR
fi

if [ -e guessCAbetE.inp ] ; then
  cp guessCAbetE.inp \$SCR
fi

if [ -e guessCBE.inp ] ; then
  cp guessCBE.inp \$SCR
fi

if [ -e guessCP.inp ] ; then
  cp guessCP.inp \$SCR
fi

cp basis_definition.inp \$SCR

cd \$SCR

export OMP_NUM_THREADS=$NPROC
export OMP_STACKSIZE=200MB
export OMP_SCHEDULE=GUIDED

$RXCHFPATH/$EXEC.exe >& $STARTDIR/xcOMPout.log

ls -lh

if [ -e FinalCE.dat ] ; then
  cp FinalCE.dat \$SGE_O_WORKDIR
fi

if [ -e FinalCAE.dat ] ; then
  cp FinalCAE.dat \$SGE_O_WORKDIR
fi

if [ -e FinalCAalpE.dat ] ; then
  cp FinalCAalpE.dat \$SGE_O_WORKDIR
fi

if [ -e FinalCAbetE.dat ] ; then
  cp FinalCAbetE.dat \$SGE_O_WORKDIR
fi

if [ -e FinalCBE.dat ] ; then
  cp FinalCBE.dat \$SGE_O_WORKDIR
fi

if [ -e FinalCP.dat ] ; then
  cp FinalCP.dat \$SGE_O_WORKDIR
fi

cp *.ufm \$SGE_O_WORKDIR

cd $STARTDIR
rm -r \$SCR

eof
"""
qsubcmd=qsubcmd.replace("$JOBNAME",parseopts.jobname)
qsubcmd=qsubcmd.replace("$QUEUE",parseopts.queue)
qsubcmd=qsubcmd.replace("$NPROC",str(parseopts.nproc))
qsubcmd=qsubcmd.replace("$WALLTIME",walltimestr)
qsubcmd=qsubcmd.replace("$MEMORY",memory)
qsubcmd=qsubcmd.replace("$STARTDIR",currdir)
qsubcmd=qsubcmd.replace("$USER",user)
qsubcmd=qsubcmd.replace("$RXCHFPATH",rxchfpath)
qsubcmd=qsubcmd.replace("$EXEC",parseopts.executable)

# Execute SGE script
cmd0=Popen(qsubcmd,shell=True,stdout=PIPE,stderr=PIPE)
std=cmd0.communicate()
if std[1] != "":    # Standard error
 print std[1]
if std[0] != "":    # Standard output
 print std[0]

